#include "i2c.h"
#include "common.h"
#include "freertos/task.h"
#include "sdkconfig.h" // generated by "make menuconfig"

#include "bme280.h"
#include "veml6075.h"
#include "ble.h"

#define TAG_BME280 "BME280"
#define TAG_DPSP "DEEP SLEEP"


#include <sys/time.h>
#include "esp_sleep.h"

static RTC_DATA_ATTR struct timeval sleep_enter_time;



void BME280_delay_msek(u32 msek)
{
	vTaskDelay(msek/portTICK_PERIOD_MS);
}

void bme280_compensate(struct bme280_results *res, s32 ucmp_press,
					s32 ucmp_temp, s32 ucmp_hum)
{
	res->temp = (float)bme280_compensate_temperature_double(ucmp_temp);
	res->press = (float)bme280_compensate_pressure_double(ucmp_press) / 100;
	res->hum = (float)bme280_compensate_humidity_double(ucmp_hum);
}

s32 bme280_take_readings(struct bme280_results *res)
{
	s32 ucmp_press;
	s32 ucmp_temp;
	s32 ucmp_hum;
	s32 ret;

	ret = bme280_get_forced_uncomp_pressure_temperature_humidity(
				 &ucmp_press, &ucmp_temp, &ucmp_hum);

	if (ret == SUCCESS) {
		bme280_compensate(res, ucmp_press, ucmp_temp, ucmp_hum);
	} else {
		ESP_LOGE(TAG_BME280, "measure error. code: %d", ret);
	}

	return ret;
}

void bme280_force(struct bme280_results *res) {
	s32 ret;

	struct bme280_t bme280 = {
		.bus_write = i2c_write,
		.bus_read = i2c_read,
		.dev_addr = BME280_I2C_ADDRESS2,
		.delay_msec = BME280_delay_msek
	};


	ret = bme280_init(&bme280);

	ret += bme280_set_oversamp_pressure(BME280_OVERSAMP_1X);
	ret += bme280_set_oversamp_temperature(BME280_OVERSAMP_1X);
	ret += bme280_set_oversamp_humidity(BME280_OVERSAMP_1X);

	ret += bme280_set_filter(BME280_FILTER_COEFF_OFF);
	if (ret == SUCCESS) {
		bme280_take_readings(res);
		ESP_LOGW(TAG_BME280, "%.2f degC / %.3f hPa / %.3f %%",
					res->temp, res->press, res->hum);
	} else {
		ESP_LOGE(TAG_BME280, "init or setting error. code: %d", ret);
	}
}

void task_measure(void *ignore) {
	const int wakeup_time_sec = 5;
	const u8 bytes_cnt = sizeof(struct veml6075_results) +
			     sizeof(struct bme280_results) + 7;
	int sleep_time_ms;
	struct timeval now;
	struct veml6075_results uv_res;
	struct bme280_results tph_res;
	u8 adv[bytes_cnt];

	veml6075_force(&uv_res);
	bme280_force(&tph_res);
	struct measurements meas = {
		.uv_res = &uv_res,
		.tph_res = &tph_res
	};

	ble_prepare_binary_measurements(&meas, adv, bytes_cnt);
	ble_transmit_measurements(adv, bytes_cnt);
	BME280_delay_msek(50);
	gettimeofday(&now, NULL);
	sleep_time_ms = (now.tv_sec - sleep_enter_time.tv_sec) * 1000 +
			    (now.tv_usec - sleep_enter_time.tv_usec) / 1000;

	switch (esp_sleep_get_wakeup_cause()) {
	case ESP_SLEEP_WAKEUP_TIMER: {
		ESP_LOGI(TAG_DPSP,
			"Wake up from timer. Time spent in deep sleep: %dms",
								sleep_time_ms);
		break;
	}
	case ESP_SLEEP_WAKEUP_UNDEFINED:
	default:
		ESP_LOGI(TAG_DPSP, "Not a deep sleep reset");
	}

	ESP_LOGI(TAG_DPSP, "Enabling timer wakeup, %ds", wakeup_time_sec);
	esp_sleep_enable_timer_wakeup(wakeup_time_sec * 1000000);
	gettimeofday(&sleep_enter_time, NULL);
	ESP_LOGI(TAG_DPSP, "Entering deep sleep");

	esp_deep_sleep_start();

	vTaskDelete(NULL);
}
void app_main(void)
{
	i2c_master_init();
	/*
	 *xTaskCreate(&task_bme280_forced_mode, "bme280_forced_mode",
	 *                                        2048, NULL, 6, NULL);
	 */
	xTaskCreate(&task_measure, "task_measure", 2048, NULL, 6, NULL);
}
